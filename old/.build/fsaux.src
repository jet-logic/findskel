#!/usr/bin/env python
def say1(*args):
	import sys
	w = sys.stdout.write
	def O(*s):
		o = None
		for _ in s:
			if o is None:
				o = w
			else:
				o(' ')
			o(str(_))
		if o:
			o('\n')
		else:
			w('\n')
	global say1
	say1 = O
	return say1(*args)
def say2(*args):
	global say2
	import sys
	w = sys.stderr.write
	def O(*s):
		o = None
		for x in s:
			if o is None:
				o = w
			else:
				o(' ')
			o(str(x))
		if o: o('\n')
		else: w('\n')
	say2 = O
	return say2(*args)
from sys import stdout as __w2;
__w2 = __w2.write;
def put2(*s):
	for _ in s: __w2(_);
class iteropt:
	class StringObj:
		def __init__(self, s):
			self.s = s
		def __str__(self):
			return self.s
# constructor:
	def __init__(self, a = None):
		if not a:
			from sys import argv
			a = iter(argv)
			try: # skip prog name
				(getattr(a, '__next__', None) or getattr(a, 'next'))()
			except StopIteration:
				a=None
		else:
			a = iter(a)
		self.reset()
		self._arg = None
		self._argsrcs = []
		a and self._argsrcs.append(a)
# private:
	def _shift(self, jump = None):
		ss = self._argsrcs
		while len(ss) > 0:
			s = ss[0]
			try:
				return ((getattr(s, '__next__', None) or getattr(s, 'next'))())
			except StopIteration:
				pass
			ss.pop(0), self.reset()
			if jump:
				break
		return None
	def _del(self, *_):
		for x in _: hasattr(self, x) and delattr(self, x)
# public:
	def reset(self):
		self._plain = None
# public:
	def is_plain(self, *a):
		r = self.get_plain(*a)
		if r is None:
			return None
		self.plain = r
		return True
	def is_bool(self, *a):
		#~ say2('is_bool', repr(self), repr(a))
		r = self.get_bool(*a)
		if r is None:
			return None
		self.bool = not not r.value
		self.name = r.name
		return True
	def is_true(self, *a):
		if not self.is_bool(*a):
			return None
		elif not self.bool:
			raise RuntimeError('Unexpected false boolean for: ' + self.name)
		return True
	def is_string(self, *a):
		r = self.get_value(*a)
		if r is None:
			return None
		self.string = r.value
		self.name = r.name
		return True
	def is_integer(self, *a):
		r = self.get_value(*a)
		if r is None:
			return None
		self.integer = int(r.value)
		self.name = r.name
		return True
	def is_float(self, *a):
		r = self.get_value(*a)
		if r is None:
			return None
		self.float = float(r.value)
		self.name = r.name
		return True
# public:
	def is_plain_form(self):
		return self._plain and self._arg and (not hasattr(self._arg, 's'))
	def is_long_form(self):
		return self._arg and hasattr(self._arg, 's') and (not hasattr(self._arg, 'bundle'))
	def is_short_form(self):
		return self._arg and hasattr(self._arg, 's') and hasattr(self._arg, 'bundle')
	def is_valid(self):
		return self._arg and True
# private:
	def _get_p(self, *args):
		r = self._arg
		self._arg = None
		return r
	def _get_d_b(self, *args):
		#~ say2('_get_d_b', repr(self), repr(args))
		r = self._arg
		if r.name2 in args:
			r.index += 1
			(r.name, r.value) = (r.name2, True)
			if r.index < len(r.bundle):
				(r.name2, r.proceed)  = (r.bundle[ r.index ], True)
			else:
				self._arg = None
			return r
		return None
	def _get_d_v(self, *args):
		r = self._arg
		if r.name2 in args:
			r.index += 1
			#~ raise ValueError(str(self._arg))
			r.value = (r.index < len(r.bundle)) and r.bundle[ self._arg.index : ] or self._shift()
			if r.value is not None:
				(r.name, self._arg) = (r.name2, None)
			return r
		return None
	def _get_dd_v(self, *args):
		key = self._arg.name2
		for name in args:
			if key == name:
				self._arg.name = name
				self._arg.value = self._shift()
				if self._arg.value is not None:
					key = self._arg
					self._arg = None
					return key
				raise ValueError(str(self._arg))
		return None
	def _get_dde_v(self, *args):
		key = self._arg.name
		for name in args:
			if key == name:
				key = self._arg
				self._arg = None
				return key
		return None
	def _get_dd_b(self, *args):
		key = self._arg.name
		for name in args:
			if key == name:
				key = self._arg
				self._arg = None
				return key
		return None
# public:
	def next(self):
		m = None
		if self._arg is not None:
			if getattr(self._arg,'proceed',None):
				self._arg.proceed = None
				return 1
			else:
				raise RuntimeError('Invalid argument: ' + str(self._arg))
		self.get_value = lambda *a: None
		self.get_bool = lambda *a: None
		self.get_plain = lambda *a: None
		self._del('plain','bool','string','integer','float','name')
		self._arg = self._shift(True)
		if self._arg is None:
			return None
		elif self._plain or ('-' == self._arg):
			pass
		elif ('--' == self._arg):
			self._plain = True
			self._arg = self._shift()
			if self._arg is None:
				return None
		elif self._arg.startswith('--') and ('=' in self._arg):
			m = self._arg
			self._arg = self.StringObj(m)
			m = m.split('=', 2)
			self._arg.name = m[0][2:]
			self._arg.value = m[1]
			self.get_value = self._get_dde_v
			return True
		elif self._arg.startswith('--'):
			m = self._arg
			self._arg = self.StringObj(m)
			m = m[2:]
			self._arg.name2 = m
			if m.startswith('no-'):
				self._arg.name = m[3:]
				self._arg.value = False
			elif m.startswith('no'):
				self._arg.name = m[2:]
				self._arg.value = False
			else:
				self._arg.name = m
				self._arg.value = True
			self.get_value = self._get_dd_v
			self.get_bool = self._get_dd_b
			return True
		elif self._arg.startswith('-'):
			m = self._arg
			self._arg = self.StringObj(m)
			m = m[1:]
			self._arg.bundle = m
			self._arg.index = 0
			self._arg.name2 = m[ self._arg.index ]
			self.get_value = self._get_d_v
			self.get_bool = self._get_d_b
			return True
		self.get_plain = self._get_p
		return True
class Counter:
	def __getattr__(self, name):
		return self.__dict__.setdefault(name, 0);
	def __contains__(self, name):
		return name in self.__dict__;
	def __iter__(self):
		return iter(self.__dict__);
	def __getitem__(self, name):
		return self.__dict__.setdefault(name, 0);
	def __setitem__(self, key, value):
		self.__dict__[key] = value;
	def __str__(self):
		return ' '.join(('%s %d;' % (k, v) for (k, v) in self.__dict__.items()))
class DO:
	def __getattr__(self, name):
		return self.__dict__.get(name);
	def __contains__(self, name):
		return name in self.__dict__;
	def __iter__(self):
		return iter(self.__dict__);
	def __getitem__(self, name):
		return getattr(self, name);
	def __setitem__(self, key, value):
		self.__dict__[key] = value;
	def setdefault(self, key, value = None):
		return self.__dict__.setdefault(key, value);
def glob_param(g, flags=0):
	import re;
	from os.path import split, normpath;
	from os import sep, altsep;
	#~ g = normpath(g);
	if altsep:
		g = g.replace(altsep, sep);
	(h, t) = split(g);
	# The tail part will never contain a slash; if path ends in a slash, tail will be empty.
	dirOnly = (len(t) < 1);
	if dirOnly:
		g = h; # bye trail sep
	# If there is no slash in path, head will be empty.
	nameOnly = (len(h) < 1) or (sep not in g);
	atStart = (g[0] == sep);
	if not (('*' in g) or ('?' in g) or ('[' in g) or atStart):
		#~ say2((g, dirOnly, nameOnly));
		return (g, dirOnly, nameOnly);
	anyn = nameOnly and '.*' or ('[^' + re.escape(sep) + ']*')
	any1 = nameOnly and '.' or ('[^' + re.escape(sep) + ']')
	#~ say2(repr((g[0] == sep, g[0], sep, g[1:len(g)])));
	if atStart:
		g = g[1:len(g)]
	i, n = 0, len(g)
	res = ''
	#~ say2(repr((res, g)));
	while i < n:
		c = g[i]
		i = i+1
		if c == '*':
			if i < n and '*' == g[i]:
				i = i+1
				res = res + '.*'
			else:
				res = res + anyn
		elif c == '?':
			res = res + any1
		elif c == '[':
			j = i
			if j < n and g[j] == '!':
				j = j+1
			if j < n and g[j] == ']':
				j = j+1
			while j < n and g[j] != ']':
				j = j+1
			if j >= n:
				res = res + '\\['
			else:
				stuff = g[i:j].replace('\\','\\\\')
				i = j+1
				if stuff[0] == '!':
					stuff = '^' + stuff[1:]
				elif stuff[0] == '^':
					stuff = '\\' + stuff
				res = '%s[%s]' % (res, stuff)
		else:
			res = res + re.escape(c)
	if atStart:
		res = ('\A(?ms)' + res)
	else:
		res = (res + '\Z(?ms)')
	#~ say2((re.compile(res).pattern, dirOnly, nameOnly))
	return (re.compile(res, flags), dirOnly, nameOnly)

class glob_match(object):
	__slots__ = ('glob', 'dirOnly', 'nameOnly')
	def __init__(self, g, icase=None):
		if icase:
			import re
			g, self.dirOnly, self.nameOnly = glob_param(g, re.I)
		else:
			g, self.dirOnly, self.nameOnly = glob_param(g)
		if hasattr(g, 'search'):
			self.glob = lambda x: bool(g.match(x))
		elif icase:
			g = g.lower()
			self.glob = lambda x: x.lower() == g
		else:
			self.glob = lambda x: x == g
	def match(self, p):
		if self.dirOnly and (not p.isdir): return False;
		p = self.nameOnly and p.name or p.rel
		#~ say2('match', repr((True, p)));
		return self.glob(p)
def ntHardLinkInfo(*args):
	#print('ntHardLinkInfo', args)
	global ntHardLinkInfo
	from ctypes import windll, c_uint32, c_wchar_p, c_void_p, WinError, create_string_buffer, byref;
	from struct import unpack;
	(GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE) = (c_uint32(0x80000000), c_uint32(0x00000001), c_uint32(3), 0x00000080, c_void_p(-1));
	FILE_FLAG_BACKUP_SEMANTICS   = 0x02000000
	CreateFileW = windll.kernel32.CreateFileW;
	GetFileInformationByHandle = windll.kernel32.GetFileInformationByHandle;
	CloseHandle = windll.kernel32.CloseHandle;
	def O(file, flag = None):
		FileName = c_wchar_p(file);
		FileHandle = CreateFileW(FileName, GENERIC_READ, FILE_SHARE_READ, None, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS+FILE_ATTRIBUTE_NORMAL, None);
		if FileHandle == -1:
			raise WinError();
		try:
			buf = create_string_buffer(52);
			if GetFileInformationByHandle(FileHandle, byref(buf)):
				(v, n, h, l) = unpack("<28xL8xLLL", buf.raw);
			else:
				raise WinError();
		finally:
			if not CloseHandle(FileHandle):
				raise WinError();
		return (v, (h << 32) | l, n)
	ntHardLinkInfo = O;
	return ntHardLinkInfo(*args);
class PathItem:
	def __init__(self, p):
		self.path = p
	def __getattr__(self, name):
		if name == 'stat':
			from os import stat
			try:
				self.__dict__[name] = stat(self.path)
			except:
				from sys import stderr
				stderr.write("Stat failed %r" % self.path)
				raise
		elif name in ('parent', 'name'):
			from os.path import split
			(self.__dict__['parent'], self.__dict__['name']) = split(self.path)
		elif 'mtime' == name:
			self.__dict__[name] = int(self.stat.st_mtime)
		elif 'size' == name:
			self.__dict__[name] = self.stat.st_size
		elif 'isdir' == name:
			from stat import S_ISDIR
			self.__dict__[name] = bool(S_ISDIR(self.stat.st_mode))
		elif 'islink' == name:
			from stat import S_ISLNK
			self.__dict__[name] = bool(S_ISLNK(self.stat.st_mode))
		elif hasattr(self.stat, name):
			if name in ('st_ino', 'st_dev', 'st_nlink'):
				if self.stat.st_ino == 0 and os.name == 'nt':
					(self.st_dev, self.st_ino, self.st_nlink) = ntHardLinkInfo(self.path)
					return self.__dict__[name]
			self.__dict__[name] = getattr(self.stat, name)
		elif 'walk' == name:
			self.__dict__[name] = None
		elif 'depth' == name:
			self.__dict__[name] = 0
		elif 'rel' == name:
			self.__dict__[name] = ''
		try:
			return self.__dict__[name]
		except KeyError:
			raise AttributeError(name)
	def __contains__(self, name):
		return (name in self.__dict__) or (name in ('stat', 'md5', 'parent', 'name', 'mtime', 'size', 'isdir', 'islink'))
	def reset(self, p = None):
		self.__dict__.clear()
		if p:
			self.path = p

def loadModule(ctx, value):
	from imp import find_module, load_module
	from os.path import splitext, basename, isfile, dirname
	(mo, parent, title) = (None, dirname(value), basename(value))
	if isfile(value):
		(title, _) = splitext(title)
	if parent:
		mo = find_module(title, [parent])
	else:
		mo = find_module(title)
	if mo:
		mo = load_module(title, *mo)
	return mo

def insert_level_filter(ctx, w):
	ctx._l = 0
	if ctx.maxLevel:
		def l_inc(c, _):
			if c._l >= c.maxLevel:
				return True
			c._l += 1
		w.cbEnter.append(l_inc)
	else:
		def l_inc(c, _): c._l += 1
		w.cbEnter.append(l_inc)
	if ctx.minLevel:
		def l_min(c, _):
			if c._l < c.minLevel:
				return True
		w.cbItem.insert(0, l_min)
	def l_dec(c, _): c._l -= 1
	w.cbLeave.append(l_dec)
	#~ w.cbItem.append((lambda _, p: sys.stdout.write(str(ctx._l))))

def insert_type_filter(ctx, w, x):
	import stat
	_t = []
	for _ in (('d', stat.S_ISDIR), ('c', stat.S_ISCHR), ('b', stat.S_ISBLK), ('f', stat.S_ISREG), ('p', stat.S_ISFIFO), ('l', stat.S_ISLNK), ('s', stat.S_ISSOCK)):
		(_[0] in x) and _t.append(_[1])
	def f_type(_, p):
		p = p.st_mode
		for _ in _t:
			if _(p): return
		return True
	w.insert(0, f_type)

def parseBinSize(x):
	from re import match
	m = match(r'^(\d+(?:\.\d+)?)\s*([kKmMgG](?:ib|b)?|b?)$', x)
	if m:
		x = m.group(2).lower()
		b = ('i' in x)
		return int(float(m.group(1)) * (
			(('k' in x) and (b and 0x400 or 1000)) or
			(('m' in x) and (b and 0x100000 or 1000000)) or
			(('g' in x) and (b and 0x40000000 or 1000000000)) or
			1))
	raise ValueError(x)
def print_func(tail = None, sep = '\n', format = None):
	import sys;
	global w__;
	w__ = sys.stdout.write;
	def p0(x):
		global w__;
		try:
			w__(x);
		except UnicodeEncodeError:
			sys.stdout.flush();
			if hasattr(sys.stdout, 'buffer'):
				W__ = sys.stdout.buffer.write;
			else:
				W__ = sys.stdout.write;
			if sys.stdout.isatty( ):
				w__ = lambda x: W__(x.encode('mbcs', 'replace'));
			else:
				w__ = lambda x: W__(x.encode('utf-8'));
			w__(x);
		w__(sep);
	if format is None:
		if tail: return lambda _, p: p0(p.name);
	elif format == 'cygwin':
		import re;
		__re = re.compile(r'^([A-Za-z]):');
		def pC(_, p):
			p = __re.sub(r'/cygdrive/\1', p.path);
			p = p.replace('\\', '/');
			p0(p);
		return pC;
	elif format == 'mingw':
		import re;
		__re = re.compile(r'^([A-Za-z]):');
		def pM(_, p):
			p = __re.sub(r'/\1', p.path);
			p = p.replace('\\', '/');
			p0(p);
		return pM;
	elif format == 'uri':
		if tail:
			try:
				from urllib import quote;
			except:
				from urllib.request import quote;
			def pU1(_, p):
				p0(quote(p.name));
			return pU1;
		try:
			from urllib import pathname2url;
		except:
			from urllib.request import pathname2url;
		def pU2(_, p):
			p = pathname2url(p.path);
			p0((p[0] == '/') and ('file:' + p) or p);
		return pU2;
	else:
		raise RuntimeError("Path format not recognized %r" % format);
	return lambda _, p: p0(p.path);

class ExStatOp:
	sort = '';
	def on_file_found(self, ctx, p):
		if not p.isdir:
			p = self.getext(p.name);
			self.map[p] = self.map.get(p, 0) + 1;
	def on_file_start(self, ctx):
		self.map = {};
		if not getattr(self, 'getext', None):
			from os.path import splitext;
			self.getext = (self.sort and ('s' in self.sort)) and (lambda x: splitext(x)[1]) or (lambda x: splitext(x.lower())[1]);
	def on_file_end(self, ctx):
		s = getattr(self, 'sort', '');
		x = self.map;
		x = sorted(zip(x.keys(), x.values()), key = (('x' in s) and (lambda x: x[0]) or (lambda x: x[1])), reverse = ('a' not in s));
		if 'v' in s:
			for k in x:	say2(k[0], k[1]);
		else:
			put2("Extension:");
			for k in x:	put2(' ', str(k[0]), ' ', str(k[1]), ';');
			put2("\n");
	def on_file_args(self, ctx, opt):
		if opt.is_string('sort'): self.sort = opt.string;

class DeleteOp:
	def on_file_found(self, ctx, p):
		if p.isdir:
			try:
				self.RD(p.path);
				self.nDir += 1;
			finally:
				say2("DEL: Dir %r" % p.path, self.CH);
		else:
			try:
				self.RM(p.path);
				self.nFile += 1;
			finally:
				say2("DEL: File %r" % p.path, self.CH);
	def on_file_start(self, ctx):
		self.nFile = 0;
		self.nDir = 0;
		if ctx.dryRun is not False:
			self.RM = lambda x: None;
			self.RD = self.RM;
			self.CH = '?';
		else:
			from os import rmdir, remove, chmod;
			from stat import S_IWRITE;
			def rd(p):
				chmod(p, S_IWRITE);
				rmdir(p);
			def rm(p):
				chmod(p, S_IWRITE);
				remove(p);
			self.RM = rm;
			self.RD = rd;
			self.CH = '!';
	def on_file_end(self, ctx):
		say2("DEL: %d Removed;" % (self.nFile+self.nDir), (self.nFile > 0) and (str(self.nFile) + " files;") or "", (self.nDir > 0) and (str(self.nDir) + " dirs;") or "");
class RenameOp:
	m_subs = [];
	m_enumMethod = 0;
	def parseSubs(self, *ss):
		import re;
		for s in ss:
			a = s[1:].split(s[0], 3);
			if len(a) < 2:
				raise RuntimeError("Invalid subtitue pattern `%s'" % s);
			s = 0;
			if len(a) > 2:
				for x in a[2]:
					s |= getattr(re, x.upper());
			self.m_subs.append((re.compile(a[0], s), a[1]));
	def on_file_found(self, ctx, f):
		name2 = None;
		name = f.name;
		if self.m_enumMethod:
			for x in self.m_subs:
				name2 = x[0].sub(x[1], name);
				if name != name2:
					break;
		else:
			name2 = name;
			for x in self.m_subs:
				x = x[0].sub(x[1], name2);
				name2 = x;
		if name2 and (name != name2):
			x = None;
			try:
				x = self.ren(f, name2);
			finally:
				if x is False:
					self.m_x += 1;
					say2("REN: %r exist!" % (name2, ));
				else:
					self.m_n += 1;
					say2("REN: %r -> %r" % (name, name2), self.clue);
	def on_file_start(self, ctx):
		self.m_n = 0;
		self.m_x = 0;
		from os.path import join, exists;
		from os import rename;
		if ctx.dryRun is not False:
			rename = lambda a,b : False;
			self.clue = '?';
		else:
			self.clue = '!';
		def ren(f,name2):
			x = join(f.parent, name2);
			if exists(x):
				return False;
			if rename(f.path, x) is not False:
				f.reset(x);
			return x;
		self.ren = ren;

	def on_file_end(self, ctx):
		say2("REN:", "%d renamed;" % self.m_n, self.m_x and ("%d exists;" % self.m_x) or "");

def binSizeBrk(n):
	(f, u) = (0, 0);
	while (n > 10000):
		f = ((n%(1 << 10)) * 100) >> 10; # (n%1024)*(100/1024)
		n = n >> 10; # n/(1**1024)
		u += 1;
	u = ((u==1) and 'k') or ((u==2) and 'M') or ((u==3) and 'G') or ((u==4) and 'T') or ((u==5) and 'P') or ((u==6) and 'E') or ((u==7) and 'Z') or ((u==8) and 'Y') or (not (u==0) and None) or '';
	return n, f, u;
def binSizeRep2(N):
	(n, f, u) = binSizeBrk(N);
	return str(n) + "." + (f > 9 and str(f) or ('0' + str(f))) + ' ' + (u and (str(u) + 'i') or '') + "B" + (u and (' (' + str(N) + ' bytes)') or "");
class StatOp:
	def on_file_found(self, ctx, p):
		if p.isdir:
			if p.rel:
				self.cDirectories += 1;
		else:
			self.nSize += p.st_size;
			self.cFiles += 1;
			if 0 == p.st_size:
				self.cEmptyFiles += 1;
			elif p.st_size > 0:
				if p.st_size > self.sizeLargest:
					self.sizeLargest = p.st_size;
					self.sizeLargestN = 1;
				elif p.st_size == self.sizeLargest:
					self.sizeLargestN += 1;
				if (self.sizeSmallest is None) or (p.st_size < self.sizeSmallest):
					self.sizeSmallest = p.st_size;
					self.sizeSmallestN = 1;
				elif (p.st_size == self.sizeSmallest):
					self.sizeSmallestN += 1;
			if self.mTimeNewest == None:
				self.mTimeNewest = p.st_mtime;
			elif p.st_mtime > self.mTimeNewest:
				self.mTimeNewest = p.st_mtime;
			elif self.mTimeOldest == None:
				self.mTimeOldest = p.st_mtime;
			elif p.st_mtime < self.mTimeOldest:
				self.mTimeOldest = p.st_mtime;
		return True;
	def on_file_start(self, ctx):
		self.sizeLargest = 0;
		self.sizeLargestN = None;
		self.sizeSmallest = None;
		self.sizeSmallestN = None;
		self.cFiles = 0;
		self.cDirectories = 0;
		self.cEmptyFiles = 0;
		self.nSize = 0;
		self.mTimeNewest = None;
		self.mTimeOldest = None;
	def on_file_end(self, ctx):
		say2("Contains:", self.cFiles, 'files', self.cDirectories, 'directories');
		say2("Size:", binSizeRep2(self.nSize));
		x = {};
		if self.cEmptyFiles: x[0] = self.cEmptyFiles;
		if self.sizeSmallest: x[self.sizeSmallest] = self.sizeSmallestN;
		if self.sizeLargest: x[self.sizeLargest] = self.sizeLargestN;
		for _ in x:
			say2("Size Range:", ' .. '.join(('%s [%d]' % (binSizeRep2(k), x[k]) for k in sorted(x.keys()))));
			break;
		self.cFiles and say2("Size Average:", binSizeRep2(self.nSize/self.cFiles));
		x = [];
		(self.mTimeNewest is None) or x.append(self.mTimeNewest);
		(self.mTimeOldest is None) or x.append(self.mTimeOldest);
		if len(x) > 0:
			from datetime import datetime;
			(len(x) > 1) and (x[-1] == x[0]) and x.pop();
			x = sorted(x);
			for i, v in enumerate(x):
				x[i] = datetime.fromtimestamp(v).isoformat();
			say2("Time Range:", ' .. '.join(x));
import sys, os, logging, os.path as path
from os import listdir
from os.path import join, normpath

gCounterMap = {}
def getCounter(name):
	global gCounterMap
	if name not in gCounterMap:
		gCounterMap[name] = Counter()
	return gCounterMap[name]

def listdr(f0):
	try:
		return listdir(f0.path);
	except:
		logging.exception("Failed to list %r", f0.path)
	return ()

def walk_dir_pre(f0):
	d2 = f0.depth + 1;
	for name in listdr(f0):
		f1 = f0.__class__(join(f0.path, name))
		f1.depth = d2
		f1.rel = join(f0.rel, name)
		f1.walk = None
		yield f1
		if f1.walk:
			for x in walk_dir_pre(f1):
				yield x

def walk_dir_post(f0):
	d2 = f0.depth + 1;
	for name in listdr(f0):
		f1 = f0.__class__(join(f0.path, name))
		f1.rel = join(f0.rel, name)
		f1.depth = d2
		try:
			b = f1.isdir
		except:
			logging.error("Failed to process %r" % f1.path)
			continue
		if b:
			f1.walk = True
			for x in walk_dir_post(f1):
				yield x
		yield f1

def main():
	from collections import deque;
	ctx = DO()
	ctx.nVerbosity = 1
	ctx.carryOn = None
	ctx.fnSubs = []
	ctx.iglobs = []
	ctx.xglobs = []
	##########
	args = deque()
	opt = iteropt()
	icase = None
	mo = None
	mp = None
	print_opt = {}
	op = []
	def mo_init(_):
		x = getattr(_, 'on_file_init', None)
		x and x(ctx)
		return getattr(_, 'on_file_args', None)
	while opt.next():
		if opt.is_plain():
			args.append(opt.plain)
	# Module:
		elif opt.is_string('plugin', 'p'):
			if not mp:
				from os.path import isdir;
				mp = join(sys.path[0], '_rc', 'PYTHONLIB');
				isdir(mp) and (mp not in sys.path) and sys.path.append(mp);
				mp = join(sys.path[0], 'PYTHONLIB');
				isdir(mp) and (mp not in sys.path) and sys.path.append(mp);
			mo = None;
			try:
				mo = loadModule(opt, opt.string);
			finally:
				logging.info("Module:", mo and getattr(mo, '__name__', '') or '', repr(opt.string));
			if mo:
				op.append(mo);
				x = getattr(mo, 'on_file_init', None);
				x and x(ctx);
				mo = getattr(mo, 'on_file_args', None);
				# TODO: file_register_calback
		# If there is an module option callback, give him the first chance to pop the option.
		# If he pops an option, go to next. Notice that he can't use SHORT and PLAIN option
		elif mo and opt.is_long_form() and (mo(ctx, opt) or True) and (not opt.is_valid()):
			continue;
	# Main:
		elif opt.is_bool('dry-run'):#D
			ctx.dryRun = opt.bool;
		elif opt.is_true('act'):#D
			ctx.dryRun = not opt.bool;
		elif opt.is_true('quiet'):
			ctx.nVerbosity -= 1;
		elif opt.is_true('debug'):
			globals()['_DEBUG'] = True;
	# Walk:
		elif opt.is_bool('follow', 'L'):#D
			ctx.followSymLinks = opt.bool;
		elif opt.is_string('include',):#D
			ctx.iglobs.append(glob_match(opt.string, icase));
		elif opt.is_string('exclude',):#D
			ctx.xglobs.append(glob_match(opt.string, icase));
		elif opt.is_bool('depth', 'd'):#D
			ctx.postOrder = True;
		elif opt.is_bool('carryon'):#D
			ctx.carryOn = opt.bool;
		elif opt.is_bool('icase'):#D
			icase = opt.bool;
		#~ elif opt.is_integer('maxdepth'):#D
			#~ ctx.maxLevel = opt.integer;
		#~ elif opt.is_integer('mindepth'):#D
			#~ ctx.minLevel = opt.integer;
		#~ elif opt.is_string('rname', 'e'):#D
			#~ import re;
			#~ wkr.nameRE.append(re.compile(opt.string));
	# Filter:
		elif opt.is_string('type'):#D
			ctx.fileType = opt.string;
		elif opt.is_bool('empty'):#D
			ctx.emptyCheck = opt.bool;
		elif opt.is_string('size'):
			o = opt.string.split('..', 2);
			if not ctx.Sizes:
				ctx.Sizes = [];
			if o[0] and o[1]:
				ctx.Sizes.append(sorted((parseBinSize(o[0]), parseBinSize(o[1]))))
			elif o[0]:
				ctx.Sizes.append([parseBinSize(o[0]), None]);
			else:
				ctx.Sizes.append([0, parseBinSize(o[1])])
	# Print:
		elif opt.is_true('print'):#D
			print_opt['format'] = None;
		elif opt.is_true('basename'):#D
			print_opt['tail'] = True;
		elif opt.is_true('mingw'):#D
			print_opt['format'] = 'mingw';
		elif opt.is_true('cygwin'):#D
			print_opt['format'] = 'cygwin';
		elif opt.is_true('uri'):#D
			print_opt['format'] = 'uri';
	# Pre-Operator:
		elif opt.is_true('exstat'):#D
			mo = ctx.opExStat = ExStatOp();
			mo = mo_init(mo);
		elif opt.is_true('stat'):#D
			mo = ctx.opStat = StatOp();
			mo = mo_init(mo);
	# Operator:
		elif opt.is_true('del'):#D
			ctx.opDelete = opt.bool;
		elif opt.is_string('ren'):#D
			ctx.fnSubs.append(opt.string);
	# Misc:
		elif opt.is_bool('unicode'):
			ctx.bUnicode = opt.bool;
	##########
	_T = ((getattr(ctx, 'bUnicode', None) or (os.name == 'nt')) and (sys.hexversion < 0x03000000)) and unicode or (lambda x: x);
	### Pre-Operator
	(ctx.opExStat is not None) and op.append(ctx.opExStat);
	(ctx.opStat is not None) and op.append(ctx.opStat);
	#~ ### Level Filter
	#~ (ctx.minLevel or ctx.maxLevel) and insert_level_filter(ctx, w);
	cbItem = [];
	### Operator
	if len(ctx.fnSubs):
		o = RenameOp();
		o.parseSubs(*ctx.fnSubs);
		op.append(o);
	elif ctx.opDelete:
		ctx.postOrder = True;
		op.append(DeleteOp());
	if op:
		for x in op:
			hasattr(x, 'on_file_found') and cbItem.append(x.on_file_found);
		if print_opt:
			cbItem.append(print_func(**print_opt));
	else:
		cbItem.append(print_func(**print_opt));
	### Empty Filter
	if ctx.emptyCheck:
		def f_empty(_, p):
			if not p.isdir:
				return p.size > 0;
			try:
				for _ in listdir(p.path):
					return True;
			except:
				logging.exception("Failed to list %r", p.path);
		cbItem.insert(0, f_empty);
	### SymLink Filter
	if ctx.followSymLinks is not True:
		def listdr2(f0):
			try:
				if not f0.islink: return listdir(f0.path);
			except:
				logging.exception("Failed to list %r", f0.path);
			return ();
		listdr = listdr2;
	### Size Filter
	if ctx.Sizes:
		_s = ctx.Sizes;
		def f_size(_, p):
			n = p.size
			for v in _s:
				if (n < v[0]) or ((v[1] is not None) and (n > v[1])):
					return True
		cbItem.insert(0, f_size)
	### Globs
	if ctx.iglobs:
		_i = ctx.iglobs
		def f_globs(_, p):
			for v in _i:
				if v.match(p):
					return None
			return True
		cbItem.insert(0, f_globs)
	if ctx.xglobs:
		_x = ctx.xglobs;
		def f_globs(_, p):
			for v in _x:
				if v.match(p):
					#~ if v.nameOnly:
						#~ if v.dirOnly:
							#~ continue;
					return True
			return None;
		cbItem.insert(0, f_globs)
	### Type Filter
	if ctx.fileType:
		insert_type_filter(ctx, cbItem, ctx.fileType)
	### Walk
	walk_dir = ctx.postOrder and walk_dir_post or walk_dir_pre

	def walk():
		line = None
		while True:
			if args:
				x = args.popleft()
				if x == '-':
					line = True
					continue
			elif line:
				x = sys.stdin.readline().strip()
			else:
				x = None
			if not x:
				break
			f = normpath(_T(x))
			try:
				f = PathItem(f)
				x = f.isdir
			except:
				logging.error("Path failed %r" % x)
				if ctx.carryOn:
					continue
				else:
					raise
			f.depth = 0
			f.rel = ''
			f.walk = None
			if x:
				for x in walk_dir(f):
					yield x
			else:
				yield f

	for x in op:
		hasattr(x, 'on_file_start') and x.on_file_start(ctx)

	for f in walk():
		#~ if f.walk is None:
			#~ f.walk = f.isdir
		#
		for cb in cbItem:
			x = None
			try:
				x = cb(ctx, f)
			except:
				logging.error("Failed to process %r" % f.path)
				if ctx.carryOn:
					x = True
					f.walk = False
					f.isdir = False
				else:
					raise
			if x:
				break
			elif x is False:
				f.walk = False
		#
		if f is None:
			break;
		elif f.walk is None:
			try:
				f.walk = f.isdir
			except:
				logging.error("Failed to process %r" % f.path)
				continue
	for x in op:
		hasattr(x, 'on_file_end') and x.on_file_end(ctx)
	for k in gCounterMap:
		v = gCounterMap[k]
		len(v.__dict__)  and say2(k, ':', ' '.join(('%s %d;' % (k, v) for (k, v) in v.__dict__.items())))
main()

"""
pushd K:\wrx\python\fsaux
mee --cd K:\wrx\python\fsaux -- nmake q3 && fsaux B:\menu
""";
